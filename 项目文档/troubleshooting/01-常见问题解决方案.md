# Bubbles-CN 常见问题解决方案

## 概述

本文档整理了 Bubbles-CN 项目在开发、测试、部署过程中常见问题的诊断方法和解决策略，帮助开发者快速定位和解决问题。

## 开发问题

### 问题 1: 依赖下载失败

**症状**:
```
go: github.com/purpose168/bubbletea-cn@v0.0.0: reading github.com/purpose168/bubbletea-cn/go.mod at revision v0.0.0: unknown revision v0.0.0
```

**原因**: 
- 依赖版本不存在
- 网络连接问题
- Go 模块代理配置问题

**解决方案**:

```bash
# 方案 1: 使用本地依赖
go mod edit -replace github.com/purpose168/bubbletea-cn=../bubbletea-cn
go mod tidy

# 方案 2: 配置 Go 模块代理
go env -w GOPROXY=https://goproxy.cn,direct

# 方案 3: 清理依赖缓存
go clean -modcache
go mod download
```

**预防措施**:
- 使用稳定的依赖版本
- 配置可靠的 Go 模块代理
- 定期更新依赖

### 问题 2: 编译错误

**症状**:
```
# github.com/purpose168/bubbles-cn/textinput
textinput/textinput.go:123: undefined: cursor.Model
```

**原因**:
- 依赖未正确安装
- 导入路径错误
- 包名不匹配

**解决方案**:

```bash
# 方案 1: 检查依赖
go mod verify
go mod tidy

# 方案 2: 检查导入路径
go list -m all

# 方案 3: 重新下载依赖
go mod download
go mod tidy
```

**预防措施**:
- 使用 go mod tidy 保持依赖一致
- 定期运行 go mod verify 验证依赖
- 使用 go list 检查依赖状态

### 问题 3: 导入循环

**症状**:
```
import cycle not allowed
package github.com/purpose168/bubbles-cn/textinput
    imports github.com/purpose168/bubbles-cn/cursor
    imports github.com/purpose168/bubbles-cn/textinput
```

**原因**:
- 包之间相互导入
- 设计不合理

**解决方案**:

```go
// 方案 1: 提取公共接口到单独的包
// 创建 common/types.go
package common

type Cursor interface {
    Position() int
    SetPosition(int)
}

// 在 textinput 中使用
type Model struct {
    cursor common.Cursor
}

// 方案 2: 使用依赖注入
type Model struct {
    cursorPosition int
    setCursorPos  func(int)
}
```

**预防措施**:
- 设计清晰的包结构
- 避免循环依赖
- 使用接口解耦

### 问题 4: 类型不匹配

**症状**:
```
cannot use m (type textinput.Model) as type tea.Model in return statement:
    textinput.Model does not implement tea.Model (missing Init method)
```

**原因**:
- 未实现接口的所有方法
- 方法签名不匹配

**解决方案**:

```go
// 确保实现所有接口方法
func (m Model) Init() tea.Cmd {
    return nil
}

func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    return m, nil
}

func (m Model) View() string {
    return m.Value
}
```

**预防措施**:
- 使用编译器检查接口实现
- 参考接口定义实现方法
- 使用 go vet 检查代码

## 测试问题

### 问题 1: 测试失败

**症状**:
```
--- FAIL: TestNew (0.00s)
    textinput_test.go:23: expected prompt '> ', got '>'
```

**原因**:
- 测试期望值错误
- 实现逻辑错误
- 测试数据不正确

**解决方案**:

```bash
# 方案 1: 运行测试并显示详细输出
go test -v ./textinput

# 方案 2: 运行测试并显示覆盖率
go test -coverprofile=coverage.out ./textinput

# 方案 3: 使用调试工具
go test -v -run TestNew ./textinput
```

**代码修复**:

```go
// 检查测试期望
func TestNew(t *testing.T) {
    ti := New()
    
    // 确保期望值正确
    expected := "> "
    if ti.Prompt != expected {
        t.Errorf("expected prompt %q, got %q", expected, ti.Prompt)
    }
}
```

**预防措施**:
- 编写清晰的测试用例
- 使用表驱动测试
- 定期运行测试

### 问题 2: 竞态条件

**症状**:
```
WARNING: DATA RACE
Read at 0x00c0000a4010 by goroutine 7:
  github.com/purpose168/bubbles-cn/textinput.(*Model).Update()
      textinput/textinput.go:123 +0x45

Previous write at 0x00c0000a4010 by goroutine 6:
  github.com/purpose168/bubbles-cn/textinput.(*Model).Update()
      textinput/textinput.go:123 +0x45
```

**原因**:
- 多个 goroutine 同时访问共享数据
- 未使用同步机制

**解决方案**:

```go
// 方案 1: 使用互斥锁
import "sync"

type Model struct {
    mu     sync.Mutex
    value  string
}

func (m *Model) SetValue(s string) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.value = s
}

// 方案 2: 使用原子操作
import "sync/atomic"

type Model struct {
    value int64
}

func (m *Model) Increment() {
    atomic.AddInt64(&m.value, 1)
}

// 方案 3: 避免共享状态
func (m Model) SetValue(s string) Model {
    m.value = s
    return m
}
```

**预防措施**:
- 使用 go test -race 检测竞态条件
- 避免共享状态
- 使用适当的同步机制

### 问题 3: 测试超时

**症状**:
```
panic: test timed out after 10m0s
```

**原因**:
- 测试中有死锁
- 测试逻辑错误
- 测试数据过大

**解决方案**:

```go
// 方案 1: 添加超时处理
func TestWithTimeout(t *testing.T) {
    done := make(chan bool)
    
    go func() {
        // 测试代码
        done <- true
    }()
    
    select {
    case <-done:
        // 测试完成
    case <-time.After(5 * time.Second):
        t.Fatal("test timed out")
    }
}

// 方案 2: 使用 context
func TestWithContext(t *testing.T) {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    // 测试代码
    select {
    case <-ctx.Done():
        t.Fatal("test timed out")
    }
}
```

**预防措施**:
- 避免死锁
- 使用超时机制
- 优化测试性能

## 部署问题

### 问题 1: 构建失败

**症状**:
```
# github.com/purpose168/bubbles-cn/textinput
textinput/textinput.go:123: undefined: cursor.Model
```

**原因**:
- 依赖未正确安装
- 环境配置错误
- Go 版本不兼容

**解决方案**:

```bash
# 方案 1: 检查 Go 版本
go version

# 方案 2: 清理构建缓存
go clean -cache
go clean -modcache

# 方案 3: 重新下载依赖
go mod download
go mod tidy

# 方案 4: 重新构建
go build -a ./...
```

**预防措施**:
- 使用正确的 Go 版本
- 保持依赖更新
- 定期清理缓存

### 问题 2: 交叉编译失败

**症状**:
```
go build: cannot load github.com/purpose168/bubbles-cn/textinput: no matching Go files in directory
```

**原因**:
- GOOS/GOARCH 设置错误
- 构建标签不匹配
- 平台特定代码

**解决方案**:

```bash
# 方案 1: 设置正确的 GOOS/GOARCH
export GOOS=linux
export GOARCH=amd64
go build ./...

# 方案 2: 使用构建标签
// +build linux

package textinput

// Linux 特定代码

// 方案 3: 使用交叉编译工具
GOOS=linux GOARCH=amd64 go build -o bubbles-cn-linux ./...
GOOS=windows GOARCH=amd64 go build -o bubbles-cn-windows.exe ./...
GOOS=darwin GOARCH=amd64 go build -o bubbles-cn-macos ./...
```

**预防措施**:
- 使用正确的 GOOS/GOARCH
- 使用构建标签
- 测试跨平台兼容性

### 问题 3: Docker 构建失败

**症状**:
```
Step 5/8 : RUN go build -o app ./...
 ---> Running in abc123def456
go: github.com/purpose168/bubbletea-cn@v0.0.0: reading github.com/purpose168/bubbletea-cn/go.mod at revision v0.0.0: unknown revision v0.0.0
```

**原因**:
- Docker 网络问题
- 依赖未正确配置
- Dockerfile 配置错误

**解决方案**:

```dockerfile
# 方案 1: 使用多阶段构建
FROM golang:1.24.2-alpine AS builder

WORKDIR /app

# 复制依赖文件
COPY go.mod go.sum ./
RUN go mod download

# 复制源代码
COPY . .

# 构建应用
RUN CGO_ENABLED=0 GOOS=linux go build -o app ./...

# 运行阶段
FROM alpine:latest

RUN apk --no-cache add ca-certificates

WORKDIR /root/

# 从构建阶段复制二进制文件
COPY --from=builder /app/app .

# 设置入口点
ENTRYPOINT ["./app"]
```

```bash
# 方案 2: 配置 Docker 网络
docker build --network=host -t bubbles-cn:latest .

# 方案 3: 使用本地依赖
docker build --build-arg GOPROXY=https://goproxy.cn,direct -t bubbles-cn:latest .
```

**预防措施**:
- 使用多阶段构建
- 配置正确的网络
- 使用可靠的依赖源

## 运行时问题

### 问题 1: 终端显示异常

**症状**:
```
终端显示乱码或格式错误
```

**原因**:
- 终端不支持 ANSI 转义序列
- 终端颜色支持不足
- 字符编码问题

**解决方案**:

```go
// 方案 1: 检测终端能力
import "github.com/purpose168/lipgloss-cn"

func checkTerminal() {
    // 检测颜色支持
    if !lipgloss.HasColor() {
        // 禁用颜色
        lipgloss.SetColor(false)
    }
    
    // 检测宽度
    width := lipgloss.Width()
    if width < 80 {
        // 调整布局
    }
}

// 方案 2: 使用备用模式
import tea "github.com/purpose168/bubbletea-cn"

p := tea.NewProgram(model, tea.WithAltScreen(false))
```

**预防措施**:
- 检测终端能力
- 提供备用模式
- 使用标准的 ANSI 转义序列

### 问题 2: 性能问题

**症状**:
```
界面卡顿或响应缓慢
```

**原因**:
- 渲染性能差
- 状态更新频繁
- 内存泄漏

**解决方案**:

```go
// 方案 1: 优化渲染
func (m Model) View() string {
    var b strings.Builder
    b.WriteString(m.Prompt)
    b.WriteString(m.Value)
    return b.String()
}

// 方案 2: 使用对象池
var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(strings.Builder)
    },
}

func (m Model) View() string {
    b := bufferPool.Get().(*strings.Builder)
    defer func() {
        b.Reset()
        bufferPool.Put(b)
    }()
    
    b.WriteString(m.Prompt)
    b.WriteString(m.Value)
    return b.String()
}

// 方案 3: 减少状态更新
func (m Model) Update(msg tea.Msg) (Model, tea.Cmd) {
    // 只在必要时返回新的模型
    if !needsUpdate(msg) {
        return m, nil
    }
    
    // 更新逻辑
    return m, nil
}
```

**预防措施**:
- 使用性能分析工具
- 优化渲染逻辑
- 减少不必要的更新

### 问题 3: 内存泄漏

**症状**:
```
内存使用持续增长
```

**原因**:
- 未释放资源
- 循环引用
- 缓存未清理

**解决方案**:

```go
// 方案 1: 使用 pprof 分析
import _ "net/http/pprof"

func main() {
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    p := tea.NewProgram(model)
    if _, err := p.Run(); err != nil {
        log.Fatal(err)
    }
}

// 方案 2: 使用 runtime 检查
import "runtime"

func checkMemory() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    log.Printf("Alloc = %v MiB", m.Alloc/1024/1024)
    log.Printf("TotalAlloc = %v MiB", m.TotalAlloc/1024/1024)
    log.Printf("Sys = %v MiB", m.Sys/1024/1024)
    log.Printf("NumGC = %v", m.NumGC)
}

// 方案 3: 清理资源
func (m Model) cleanup() {
    // 清理缓存
    m.cache = nil
    
    // 关闭文件
    if m.file != nil {
        m.file.Close()
    }
    
    // 停止定时器
    if m.timer != nil {
        m.timer.Stop()
    }
}
```

**预防措施**:
- 使用 pprof 分析内存
- 定期检查内存使用
- 及时释放资源

## 依赖问题

### 问题 1: 依赖冲突

**症状**:
```
go: github.com/purpose168/bubbletea-cn@v0.0.0 requires github.com/purpose168/lipgloss-cn@v0.0.0: conflicting versions
```

**原因**:
- 依赖版本不兼容
- 间接依赖冲突

**解决方案**:

```bash
# 方案 1: 查看依赖树
go mod graph | grep lipgloss

# 方案 2: 强制使用特定版本
go get github.com/purpose168/lipgloss-cn@v0.0.1

# 方案 3: 使用 replace 指令
go mod edit -replace github.com/purpose168/lipgloss-cn=../lipgloss-cn

# 方案 4: 整理依赖
go mod tidy
```

**预防措施**:
- 使用语义化版本
- 定期更新依赖
- 使用 go mod tidy

### 问题 2: 依赖安全漏洞

**症状**:
```
GO-2023-XXXX: Vulnerability in github.com/purpose168/bubbletea-cn
```

**原因**:
- 依赖存在已知漏洞
- 未及时更新依赖

**解决方案**:

```bash
# 方案 1: 检查漏洞
go install golang.org/x/vuln/cmd/govulncheck@latest
govulncheck ./...

# 方案 2: 更新依赖
go get -u ./...
go mod tidy

# 方案 3: 使用特定版本
go get github.com/purpose168/bubbletea-cn@v0.0.1
```

**预防措施**:
- 定期检查漏洞
- 及时更新依赖
- 使用 govulncheck

## 文档问题

### 问题 1: 文档不完整

**症状**:
```
API 文档缺少说明
```

**原因**:
- 未编写注释
- 注释不完整
- 文档未更新

**解决方案**:

```go
// 方案 1: 添加完整的注释
// Package textinput 提供了用于 Bubble Tea 应用程序的文本输入组件。
//
// 基本用法：
//
//	ti := textinput.New()
//	ti.Placeholder = "请输入内容"
//	ti.Focus()
//
// 文本输入组件支持：
//   - 光标导航
//   - 文本编辑
//   - 粘贴支持
//   - 输入验证
package textinput

// New 创建一个新的文本输入模型。
// 返回的模型使用默认配置，可以通过链式调用方法进行自定义。
func New() Model {
    return Model{
        Prompt:  "> ",
        EchoMode: EchoNormal,
    }
}

// 方案 2: 生成文档
go doc -all ./textinput

// 方案 3: 使用 godoc
godoc -http=:6060
```

**预防措施**:
- 编写完整的注释
- 定期更新文档
- 使用 godoc 生成文档

### 问题 2: 示例代码错误

**症状**:
```
示例代码无法运行
```

**原因**:
- 示例代码过时
- API 变化未更新示例

**解决方案**:

```go
// 方案 1: 测试示例代码
func ExampleNew() {
    ti := New()
    ti.Placeholder = "请输入内容"
    ti.Focus()
    
    fmt.Println(ti.View())
    // Output: > 请输入内容
}

// 方案 2: 定期运行示例
go test -run Example

// 方案 3: 更新示例
// 确保示例代码与最新 API 同步
```

**预防措施**:
- 测试示例代码
- 定期更新示例
- 使用 Example 测试

## 工具问题

### 问题 1: golangci-lint 错误

**症状**:
```
textinput/textinput.go:123:1: exported function New should have comment or be unexported (golint)
```

**原因**:
- 代码不符合规范
- 配置错误

**解决方案**:

```bash
# 方案 1: 查看详细错误
golangci-lint run -v

# 方案 2: 自动修复
golangci-lint run --fix

# 方案 3: 配置忽略规则
# .golangci.yml
linters:
  disable:
    - golint
```

**预防措施**:
- 遵循编码规范
- 定期运行 lint
- 配置适当的规则

### 问题 2: Makefile 错误

**症状**:
```
make: *** No rule to make target 'test'.  Stop.
```

**原因**:
- Makefile 配置错误
- 目标不存在

**解决方案**:

```makefile
# 方案 1: 添加缺失的目标
.PHONY: test
test:
	go test ./...

# 方案 2: 检查 Makefile 语法
make -n test

# 方案 3: 使用正确的目标
make help
```

**预防措施**:
- 测试 Makefile
- 提供帮助信息
- 使用 .PHONY 声明

## 总结

Bubbles-CN 项目在开发、测试、部署过程中可能会遇到各种问题。本文档提供了常见问题的诊断方法和解决策略，帮助开发者快速定位和解决问题。

### 问题解决要点

1. **诊断问题**: 准确识别问题的症状和原因
2. **查找解决方案**: 参考本文档提供的解决方案
3. **实施修复**: 按照步骤实施修复
4. **验证结果**: 确认问题已解决
5. **预防措施**: 采取预防措施避免问题再次发生

### 获取帮助

如果本文档中没有找到解决方案，可以通过以下方式获取帮助：

1. **查看文档**: 阅读项目文档和 API 文档
2. **搜索问题**: 在 GitHub Issues 中搜索类似问题
3. **提问**: 在 GitHub Issues 中提问
4. **联系**: 联系项目维护者

### 持续改进

本文档会根据实际问题和解决方案持续更新。欢迎开发者提供反馈和建议。
