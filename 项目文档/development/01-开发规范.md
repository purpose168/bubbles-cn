# Bubbles-CN 开发规范

## 概述

本文档制定了 Bubbles-CN 项目的开发规范，包括编码规范、命名规范、代码审查标准及文档编写规范，确保代码质量和团队协作效率。

## 编码规范

### Go 语言规范

Bubbles-CN 遵循 Go 语言官方编码规范，并在此基础上制定了一些补充规范。

#### 基本规范

1. **格式化**: 使用 `gofmt` 格式化所有代码
2. **导入顺序**: 按照标准库、第三方库、本地库的顺序导入
3. **行长度**: 建议不超过 120 字符
4. **缩进**: 使用 tab 缩进，不使用空格
5. **大括号**: 左大括号不换行

#### 示例

```go
// 正确的导入顺序
package textinput

import (
    "errors"
    "strings"
    "time"
    
    "github.com/atotto/clipboard"
    "github.com/mattn/go-runewidth"
    
    "github.com/purpose168/bubbles-cn/cursor"
    "github.com/purpose168/bubbles-cn/key"
    tea "github.com/purpose168/bubbletea-cn"
)

// 正确的函数定义
func (m Model) Update(msg tea.Msg) (Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.KeyMsg:
        // 处理按键
    }
    return m, nil
}
```

### 注释规范

#### 包注释

每个包都应该有包注释，说明包的用途。

```go
// Package textinput 为 Bubble Tea 应用程序提供文本输入组件。
// 支持单行文本输入、光标导航、粘贴操作等功能。
package textinput
```

#### 函数注释

导出的函数必须有注释，说明函数的用途、参数和返回值。

```go
// New 创建一个新的文本输入模型。
// 返回的模型使用默认配置，可以通过链式调用方法进行自定义。
func New() Model {
    return Model{
        Prompt:       "> ",
        EchoMode:      EchoNormal,
        EchoCharacter: '•',
        CharLimit:     0,
    }
}
```

#### 方法注释

导出的方法必须有注释，说明方法的功能。

```go
// Update 处理消息并更新模型状态。
// 支持键盘消息、剪贴板消息等。
func (m Model) Update(msg tea.Msg) (Model, tea.Cmd) {
    // 实现
}
```

#### 类型注释

导出的类型必须有注释，说明类型的用途。

```go
// Model 是文本输入元素的 Bubble Tea 模型。
// 包含输入框的所有状态和配置。
type Model struct {
    Value    string       // 当前输入值
    Cursor   cursor.Model // 光标模型
    Prompt   string       // 提示符
}
```

#### 字段注释

结构体的重要字段应该有注释。

```go
type Model struct {
    Err          error        // 验证错误
    Prompt       string       // 提示符
    Placeholder  string       // 占位符文本
    EchoMode     EchoMode     // 回显模式
    EchoCharacter rune         // 回显字符（用于密码模式）
    Cursor       cursor.Model // 光标模型
    Value        string       // 当前值
    Width        int          // 宽度
    CharLimit    int          // 字符限制
}
```

### 错误处理规范

1. **错误返回**: 函数返回错误时，错误应该是最后一个返回值
2. **错误检查**: 必须检查所有可能的错误
3. **错误包装**: 使用 `fmt.Errorf` 包装错误时，应该添加上下文信息
4. **错误变量**: 定义公共错误变量以便比较

#### 示例

```go
// 定义公共错误变量
var (
    ErrInvalidInput = errors.New("invalid input")
    ErrTimeout     = errors.New("operation timeout")
)

// 错误处理示例
func (m Model) SetValue(s string) (Model, error) {
    if m.Validate != nil {
        if err := m.Validate(s); err != nil {
            return m, fmt.Errorf("validation failed: %w", err)
        }
    }
    m.Value = s
    return m, nil
}
```

### 并发规范

1. **避免共享状态**: 组件应该是无状态的，状态通过消息传递
2. **使用 channel**: 使用 channel 进行 goroutine 间通信
3. **避免竞态条件**: 使用 `go test -race` 检测竞态条件

#### 示例

```go
// 使用 channel 进行通信
func (m Model) startTimer() tea.Cmd {
    return tea.Tick(m.Interval, func(t time.Time) tea.Msg {
        return TickMsg(t)
    })
}

// 避免共享状态
func (m Model) Update(msg tea.Msg) (Model, tea.Cmd) {
    // 返回新的模型，而不是修改现有模型
    newModel := m
    newModel.Value = "new value"
    return newModel, nil
}
```

## 命名规范

### 包命名

1. **小写**: 包名使用小写字母
2. **简洁**: 包名应该简洁明了
3. **单数**: 包名使用单数形式
4. **避免下划线**: 不使用下划线

#### 示例

```
textinput    // 正确
textarea     // 正确
text_input   // 错误（使用下划线）
TextInput    // 错误（使用大写）
```

### 函数命名

1. **导出函数**: 首字母大写
2. **私有函数**: 首字母小写
3. **动词开头**: 函数名以动词开头
4. **驼峰命名**: 使用驼峰命名法

#### 示例

```go
// 导出函数
func New() Model
func Update(msg tea.Msg) (Model, tea.Cmd)
func View() string

// 私有函数
func calculateWidth(s string) int
func validateInput(s string) error
```

### 方法命名

1. **接收者命名**: 接收者使用简短的名称（通常 1-2 个字符）
2. **一致性**: 同一类型的方法命名应该一致
3. **链式调用**: 返回值类型为接收者类型的方法应该支持链式调用

#### 示例

```go
// 接收者命名
func (m Model) Update(msg tea.Msg) (Model, tea.Cmd) {
    // m 是 Model 的缩写
}

// 链式调用
func (m Model) SetValue(s string) Model {
    m.Value = s
    return m
}

func (m Model) SetWidth(w int) Model {
    m.Width = w
    return m
}

// 使用
model := New().SetValue("test").SetWidth(20)
```

### 变量命名

1. **驼峰命名**: 使用驼峰命名法
2. **有意义的名称**: 变量名应该有意义
3. **缩写**: 常见缩写可以使用（如 `msg`, `cmd`, `err`）
4. **避免单字母**: 避免使用单字母变量名（除了循环变量）

#### 示例

```go
// 正确
var (
    textInput textinput.Model
    list      list.Model
    help      help.Model
)

// 错误
var (
    t textinput.Model
    l list.Model
    h help.Model
)
```

### 常量命名

1. **大写**: 常量使用大写字母
2. **下划线分隔**: 使用下划线分隔单词
3. **导出常量**: 首字母大写
4. **私有常量**: 首字母小写

#### 示例

```go
// 导出常量
const (
    DefaultWidth = 80
    DefaultHeight = 24
)

// 私有常量
const (
    maxRetries = 3
    timeout = 30 * time.Second
)

// 枚举类型
const (
    EchoNormal EchoMode = iota
    EchoPassword
    EchoNone
)
```

### 接口命名

1. **动词结尾**: 接口名以动词结尾（如 `Reader`, `Writer`）
2. **单个方法**: 如果接口只有一个方法，使用方法名 + `-er` 后缀
3. **描述性**: 接口名应该描述其功能

#### 示例

```go
// 单个方法的接口
type Item interface {
    FilterValue() string
}

// 多个方法的接口
type ItemDelegate interface {
    Render(w io.Writer, m Model, index int, item Item)
    Height() int
    Spacing() int
    Update(msg tea.Msg, m *Model) tea.Cmd
}
```

## 代码审查标准

### 审查清单

#### 功能性

- [ ] 代码实现了预期的功能
- [ ] 边界条件得到正确处理
- [ ] 错误处理完整且合理
- [ ] 性能满足要求

#### 可读性

- [ ] 代码易于理解
- [ ] 变量和函数命名清晰
- [ ] 注释充分且准确
- [ ] 代码结构合理

#### 可维护性

- [ ] 代码模块化良好
- [ ] 避免重复代码
- [ ] 遵循项目规范
- [ ] 易于扩展和修改

#### 安全性

- [ ] 没有安全漏洞
- [ ] 输入验证充分
- [ ] 资源正确释放
- [ ] 没有竞态条件

#### 测试

- [ ] 有充分的单元测试
- [ ] 测试覆盖关键路径
- [ ] 测试通过
- [ ] 没有竞态条件

### 审查流程

1. **提交 PR**: 开发者提交 Pull Request
2. **自动检查**: CI/CD 自动运行测试和代码检查
3. **人工审查**: 至少一名维护者进行人工审查
4. **修改**: 根据审查意见进行修改
5. **批准**: 审查通过后批准合并
6. **合并**: 合并到主分支

### 审查意见

审查意见应该：
- **具体**: 指出具体的问题
- **建设性**: 提供改进建议
- **礼貌**: 保持友好的态度
- **及时**: 及时反馈审查意见

## 文档编写规范

### 代码文档

#### 包文档

每个包都应该有 `doc.go` 文件或在主文件中包含包文档。

```go
// Package textinput 提供了用于 Bubble Tea 应用程序的文本输入组件。
//
// 基本用法：
//
//	ti := textinput.New()
//	ti.Placeholder = "请输入内容"
//	ti.Focus()
//
//	// 在 Update 中处理消息
//	ti, cmd := ti.Update(msg)
//
//	// 在 View 中渲染
//	view := ti.View()
//
// 文本输入组件支持：
//   - 光标导航（左右移动、跳到行首/行尾）
//   - 文本编辑（插入、删除、粘贴）
//   - 回显模式（正常、密码、无回显）
//   - 输入验证
//   - 自定义样式
package textinput
```

#### 示例代码

提供清晰、完整的示例代码。

```go
// ExampleNew 漕示如何创建和使用文本输入组件。
func ExampleNew() {
    ti := textinput.New()
    ti.Placeholder = "请输入用户名"
    ti.Focus()
    
    fmt.Println(ti.View())
    // Output: > 请输入用户名
}
```

### README 文档

每个组件目录都应该有 README.md 文件，说明组件的用途和用法。

```markdown
# TextInput

文本输入组件，用于单行文本输入。

## 特性

- 光标导航
- 文本编辑
- 粘贴支持
- 输入验证
- 自定义样式

## 用法

```go
ti := textinput.New()
ti.Placeholder = "请输入内容"
ti.Focus()
```

## API 文档

参见 [GoDoc](https://pkg.go.dev/github.com/purpose168/bubbles-cn/textinput)
```

### 项目文档

项目文档应该包括：
- 项目概述
- 架构设计
- 模块说明
- API 文档
- 使用指南
- 贡献指南

## 版本控制规范

### 分支策略

```
main (主分支)
  │
  ├── develop (开发分支)
  │     │
  │     ├── feature/* (功能分支)
  │     ├── bugfix/* (修复分支)
  │     └── hotfix/* (紧急修复分支)
  │
  └── release/* (发布分支)
```

#### 分支说明

| 分支类型 | 用途 | 命名规范 |
|---------|------|---------|
| **main** | 主分支，稳定版本 | main |
| **develop** | 开发分支，最新开发版本 | develop |
| **feature** | 功能开发 | feature/功能名称 |
| **bugfix** | Bug 修复 | bugfix/问题描述 |
| **hotfix** | 紧急修复 | hotfix/问题描述 |
| **release** | 发布准备 | release/版本号 |

### 提交规范

#### 提交信息格式

```
<类型>(<范围>): <描述>

[可选的正文]

[可选的脚注]
```

#### 类型

| 类型 | 说明 |
|------|------|
| **feat** | 新功能 |
| **fix** | Bug 修复 |
| **docs** | 文档更新 |
| **style** | 代码格式（不影响功能） |
| **refactor** | 重构 |
| **perf** | 性能优化 |
| **test** | 测试相关 |
| **chore** | 构建/工具相关 |

#### 示例

```
feat(textinput): 添加粘贴功能

实现了剪贴板粘贴功能，支持 Ctrl+V 快捷键。

Closes #123
```

```
fix(list): 修复过滤时的索引错误

修复了在过滤列表后，光标位置计算错误的问题。
```

## 测试规范

### 单元测试

1. **测试文件**: 测试文件以 `_test.go` 结尾
2. **测试函数**: 测试函数以 `Test` 开头
3. **覆盖率**: 目标覆盖率 80% 以上
4. **测试命名**: 测试函数名应该描述测试的内容

#### 示例

```go
func TestNew(t *testing.T) {
    ti := textinput.New()
    
    if ti.Prompt != "> " {
        t.Errorf("expected prompt '> ', got %q", ti.Prompt)
    }
    
    if ti.EchoMode != EchoNormal {
        t.Errorf("expected EchoNormal, got %v", ti.EchoMode)
    }
}

func TestSetValue(t *testing.T) {
    tests := []struct {
        name  string
        value string
    }{
        {"empty string", ""},
        {"normal text", "hello world"},
        {"unicode", "你好世界"},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            ti := textinput.New()
            ti = ti.SetValue(tt.value)
            
            if ti.Value != tt.value {
                t.Errorf("expected %q, got %q", tt.value, ti.Value)
            }
        })
    }
}
```

### 表驱动测试

使用表驱动测试来测试多个场景。

```go
func TestUpdate(t *testing.T) {
    tests := []struct {
        name     string
        model    Model
        msg      tea.Msg
        expected Model
    }{
        {
            name:  "character input",
            model: New(),
            msg:   tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'a'}},
            expected: Model{
                Value: "a",
                Cursor: cursor.Model{Position: 1},
            },
        },
        // 更多测试用例...
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, _ := tt.model.Update(tt.msg)
            if got.Value != tt.expected.Value {
                t.Errorf("expected value %q, got %q", tt.expected.Value, got.Value)
            }
        })
    }
}
```

### 基准测试

使用基准测试来测量性能。

```go
func BenchmarkView(b *testing.B) {
    m := New()
    m.SetValue("这是一个很长的文本")
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = m.View()
    }
}
```

## 性能规范

### 性能目标

- **渲染性能**: 视图渲染应该在 10ms 内完成
- **更新性能**: 状态更新应该在 5ms 内完成
- **内存使用**: 组件内存占用应该最小化

### 性能优化

1. **避免不必要的字符串分配**
2. **使用对象池复用对象**
3. **只渲染可见区域**
4. **使用增量更新**

#### 示例

```go
// 使用 strings.Builder 避免字符串分配
func (m Model) View() string {
    var b strings.Builder
    b.WriteString(m.Prompt)
    b.WriteString(m.Value)
    return b.String()
}

// 使用 sync.Pool 复用对象
var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(strings.Builder)
    },
}

func (m Model) View() string {
    b := bufferPool.Get().(*strings.Builder)
    defer func() {
        b.Reset()
        bufferPool.Put(b)
    }()
    
    b.WriteString(m.Prompt)
    b.WriteString(m.Value)
    return b.String()
}
```

## 安全规范

### 输入验证

1. **验证所有输入**: 验证所有用户输入
2. **限制长度**: 限制输入长度防止缓冲区溢出
3. **过滤特殊字符**: 过滤可能引起问题的特殊字符

#### 示例

```go
func (m Model) SetValue(s string) (Model, error) {
    // 验证长度
    if m.CharLimit > 0 && len(s) > m.CharLimit {
        return m, fmt.Errorf("input exceeds character limit of %d", m.CharLimit)
    }
    
    // 验证内容
    if m.Validate != nil {
        if err := m.Validate(s); err != nil {
            return m, fmt.Errorf("validation failed: %w", err)
        }
    }
    
    m.Value = s
    return m, nil
}
```

### 终端安全

1. **正确处理 ANSI 转义序列**
2. **防止终端转义序列注入**
3. **安全的剪贴板操作**

#### 示例

```go
// 使用安全的 ANSI 转义序列
import "github.com/purpose168/charm-experimental-packages-cn/ansi"

func (m Model) View() string {
    return ansi.Bold(m.Value)
}

// 不要直接拼接用户输入到 ANSI 转义序列
// 错误示例：
// return "\x1b[" + userInput + "m"  // 危险！
```

## 工具使用

### 代码格式化

```bash
# 格式化代码
gofmt -s -w .

# 使用 goimports（推荐）
goimports -w .
```

### 代码检查

```bash
# 使用 golangci-lint
golangci-lint run

# 使用 go vet
go vet ./...

# 使用 staticcheck
staticcheck ./...
```

### 测试

```bash
# 运行所有测试
go test ./...

# 运行测试并显示覆盖率
go test -cover ./...

# 运行测试并检测竞态条件
go test -race ./...

# 运行基准测试
go test -bench=. -benchmem
```

### 文档

```bash
# 生成文档
godoc -http=:6060

# 检查文档
go doc -all ./...
```

## 总结

Bubbles-CN 项目遵循严格的开发规范，确保代码质量、可维护性和团队协作效率。所有开发者都应该熟悉并遵守这些规范。

### 规范要点

1. **遵循 Go 语言规范**: 使用标准的 Go 编码风格
2. **充分注释**: 为所有导出的代码添加注释
3. **命名清晰**: 使用有意义的命名
4. **充分测试**: 编写充分的单元测试
5. **代码审查**: 所有代码都需要经过审查
6. **文档完善**: 保持文档与代码同步
7. **性能优化**: 关注性能和资源使用
8. **安全第一**: 注意输入验证和终端安全

### 持续改进

开发规范不是一成不变的，应该根据项目发展和团队反馈持续改进。欢迎提出改进建议。
