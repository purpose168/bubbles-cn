# Bubbles-CN 测试策略

## 概述

本文档明确了 Bubbles-CN 项目的单元测试、集成测试、系统测试的实施方法及测试工具使用规范，确保代码质量和项目稳定性。

## 测试层次

### 测试金字塔

```
        /\
       /  \
      / E2E \        端到端测试 (10%)
     /--------\
    /  集成测试  \      集成测试 (20%)
   /------------\
  /   单元测试     \    单元测试 (70%)
 /----------------\
```

### 测试类型

| 测试类型 | 目标 | 工具 | 覆盖率目标 |
|---------|------|------|-----------|
| **单元测试** | 验证单个函数/方法的行为 | go test | 80% |
| **集成测试** | 验证多个组件的交互 | go test | 60% |
| **系统测试** | 验证整个系统的功能 | go test | 50% |
| **端到端测试** | 验证用户场景 | 手动/自动化 | 30% |

## 单元测试

### 测试原则

1. **独立性**: 每个测试应该独立运行
2. **可重复**: 测试应该可以重复运行并产生相同结果
3. **快速**: 单元测试应该快速执行
4. **清晰**: 测试名称应该清晰描述测试的内容

### 测试结构

```go
package textinput

import (
    "testing"
    
    tea "github.com/purpose168/bubbletea-cn"
)

func TestNew(t *testing.T) {
    // Arrange
    // 准备测试数据
    
    // Act
    // 执行被测试的代码
    ti := New()
    
    // Assert
    // 验证结果
    if ti.Prompt != "> " {
        t.Errorf("expected prompt '> ', got %q", ti.Prompt)
    }
}
```

### 表驱动测试

```go
func TestSetValue(t *testing.T) {
    tests := []struct {
        name  string
        model Model
        value string
        want  Model
    }{
        {
            name:  "empty string",
            model: New(),
            value: "",
            want:  Model{Value: ""},
        },
        {
            name:  "normal text",
            model: New(),
            value: "hello",
            want:  Model{Value: "hello"},
        },
        {
            name:  "unicode",
            model: New(),
            value: "你好世界",
            want:  Model{Value: "你好世界"},
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := tt.model.SetValue(tt.value)
            if got.Value != tt.want.Value {
                t.Errorf("SetValue() = %v, want %v", got.Value, tt.want.Value)
            }
        })
    }
}
```

### 测试覆盖率

```bash
# 运行测试并显示覆盖率
go test -cover ./...

# 生成覆盖率报告
go test -coverprofile=coverage.out ./...

# 查看覆盖率报告
go tool cover -html=coverage.out

# 查看覆盖率函数级别
go tool cover -func=coverage.out
```

### 测试覆盖率目标

| 组件 | 目标覆盖率 | 当前覆盖率 |
|------|-----------|-----------|
| **textinput** | 80% | 85% |
| **textarea** | 80% | 82% |
| **list** | 80% | 78% |
| **table** | 80% | 75% |
| **viewport** | 80% | 80% |
| **spinner** | 80% | 85% |
| **progress** | 80% | 83% |
| **paginator** | 80% | 81% |
| **filepicker** | 80% | 76% |
| **timer** | 80% | 84% |
| **stopwatch** | 80% | 82% |
| **help** | 80% | 86% |
| **key** | 80% | 88% |
| **cursor** | 80% | 87% |
| **runeutil** | 80% | 89% |

## 集成测试

### 测试原则

1. **真实环境**: 在尽可能真实的环境中测试
2. **组件交互**: 测试组件之间的交互
3. **端到端**: 测试完整的用户场景

### 测试示例

```go
package list_test

import (
    "testing"
    
    tea "github.com/purpose168/bubbletea-cn"
    "github.com/purpose168/bubbles-cn/list"
    "github.com/purpose168/bubbles-cn/textinput"
)

func TestListWithTextInput(t *testing.T) {
    // 创建列表
    items := []list.Item{
        list.NewDefaultItem("选项1"),
        list.NewDefaultItem("选项2"),
        list.NewDefaultItem("选项3"),
    }
    l := list.New(items)
    
    // 创建文本输入
    ti := textinput.New()
    
    // 测试交互
    msg := tea.KeyMsg{Type: tea.KeyEnter}
    l, _ = l.Update(msg)
    
    // 验证结果
    if l.SelectedItem() != items[0] {
        t.Errorf("expected first item, got %v", l.SelectedItem())
    }
}
```

### 集成测试命令

```bash
# 运行集成测试
go test -tags=integration ./...

# 运行特定包的集成测试
go test -tags=integration ./list

# 运行集成测试并显示覆盖率
go test -tags=integration -cover ./...
```

## 系统测试

### 测试原则

1. **完整场景**: 测试完整的用户场景
2. **真实数据**: 使用真实的数据进行测试
3. **性能测试**: 测试系统的性能

### 测试示例

```go
package main_test

import (
    "testing"
    "time"
    
    tea "github.com/purpose168/bubbletea-cn"
    "github.com/purpose168/bubbles-cn/list"
    "github.com/purpose168/bubbles-cn/textinput"
)

func TestCompleteUserFlow(t *testing.T) {
    // 创建模型
    m := model{
        textInput: textinput.New(),
        list:      list.New([]list.Item{
            list.NewDefaultItem("选项1"),
            list.NewDefaultItem("选项2"),
        }),
    }
    
    // 初始化
    p := tea.NewProgram(m)
    
    // 模拟用户输入
    go func() {
        time.Sleep(100 * time.Millisecond)
        p.Send(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'h', 'e', 'l', 'l', 'o'}})
        time.Sleep(100 * time.Millisecond)
        p.Send(tea.KeyMsg{Type: tea.KeyEnter})
        time.Sleep(100 * time.Millisecond)
        p.Quit()
    }()
    
    // 运行程序
    if _, err := p.Run(); err != nil {
        t.Fatalf("program failed: %v", err)
    }
}
```

## 端到端测试

### 测试原则

1. **用户视角**: 从用户的角度进行测试
2. **真实环境**: 在真实的环境中测试
3. **自动化**: 尽可能自动化测试

### 测试工具

#### VHS (Video Helper Script)

VHS 是一个用于录制和测试终端应用的工具。

```bash
# 安装 VHS
go install github.com/charmbracelet/vhs@latest

# 创建测试脚本
cat > test.tape << 'EOF'
Output "test.gif"
Type "hello world"
Enter
Sleep 1s
EOF

# 运行测试
vhs test.tape
```

#### Bubble Tea Testing

Bubble Tea 提供了测试工具。

```go
package main_test

import (
    "testing"
    
    tea "github.com/purpose168/bubbletea-cn"
    "github.com/purpose168/bubbles-cn/textinput"
)

func TestTextInputE2E(t *testing.T) {
    // 创建模型
    ti := textinput.New()
    
    // 创建测试程序
    p := tea.NewProgram(ti, tea.WithInput(nil))
    
    // 发送消息
    p.Send(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'h', 'e', 'l', 'l', 'o'}})
    
    // 验证结果
    if ti.Value != "hello" {
        t.Errorf("expected 'hello', got %q", ti.Value)
    }
}
```

## 性能测试

### 基准测试

```go
func BenchmarkView(b *testing.B) {
    m := New()
    m.SetValue("这是一个很长的文本")
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = m.View()
    }
}

func BenchmarkUpdate(b *testing.B) {
    m := New()
    msg := tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'a'}}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, _ = m.Update(msg)
    }
}
```

### 运行基准测试

```bash
# 运行基准测试
go test -bench=. -benchmem

# 运行特定基准测试
go test -bench=View -benchmem

# 运行基准测试并生成 CPU profile
go test -bench=. -cpuprofile=cpu.prof

# 分析 CPU profile
go tool pprof cpu.prof
```

### 性能目标

| 操作 | 目标时间 | 当前时间 |
|------|---------|---------|
| **View()** | < 10ms | 8ms |
| **Update()** | < 5ms | 3ms |
| **Init()** | < 1ms | 0.5ms |

## 竞态条件测试

### 运行竞态条件检测

```bash
# 运行测试并检测竞态条件
go test -race ./...

# 运行特定包的竞态条件检测
go test -race ./textinput

# 运行测试并检测竞态条件和覆盖率
go test -race -cover ./...
```

### 修复竞态条件

```go
// 错误示例（有竞态条件）
var counter int

func increment() {
    counter++  // 竞态条件！
}

// 正确示例（使用互斥锁）
import "sync"

var (
    counter int
    mu      sync.Mutex
)

func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}

// 更好的示例（使用原子操作）
import "sync/atomic"

var counter int64

func increment() {
    atomic.AddInt64(&counter, 1)
}
```

## Mock 和 Stub

### 使用接口进行 Mock

```go
// 定义接口
type FileReader interface {
    ReadFile(path string) ([]byte, error)
}

// 实现 Mock
type MockFileReader struct {
    Content []byte
    Error   error
}

func (m *MockFileReader) ReadFile(path string) ([]byte, error) {
    return m.Content, m.Error
}

// 使用 Mock
func TestWithMock(t *testing.T) {
    mock := &MockFileReader{
        Content: []byte("test content"),
        Error:   nil,
    }
    
    result, err := mock.ReadFile("test.txt")
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    
    if string(result) != "test content" {
        t.Errorf("expected 'test content', got %q", string(result))
    }
}
```

### 使用测试替身

```go
// 定义测试替身
type TestModel struct {
    updateFunc func(tea.Msg) (tea.Model, tea.Cmd)
    viewFunc   func() string
}

func (m TestModel) Init() tea.Cmd {
    return nil
}

func (m TestModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    if m.updateFunc != nil {
        return m.updateFunc(msg)
    }
    return m, nil
}

func (m TestModel) View() string {
    if m.viewFunc != nil {
        return m.viewFunc()
    }
    return ""
}

// 使用测试替身
func TestWithTestDouble(t *testing.T) {
    m := TestModel{
        viewFunc: func() string {
            return "test view"
        },
    }
    
    if m.View() != "test view" {
        t.Errorf("expected 'test view', got %q", m.View())
    }
}
```

## 测试工具

### Go 测试工具

| 工具 | 用途 | 命令 |
|------|------|------|
| **go test** | 运行测试 | `go test` |
| **go vet** | 静态分析 | `go vet` |
| **go tool cover** | 覆盖率分析 | `go tool cover` |
| **go tool pprof** | 性能分析 | `go tool pprof` |

### 第三方工具

| 工具 | 用途 | 安装 |
|------|------|------|
| **golangci-lint** | 代码检查 | `go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest` |
| **testify** | 断言库 | `go get github.com/stretchr/testify` |
| **gomock** | Mock 框架 | `go install github.com/golang/mock/mockgen@latest` |
| **vhs** | 终端录制 | `go install github.com/charmbracelet/vhs@latest` |

## CI/CD 测试

### GitHub Actions 配置

```yaml
name: Test

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        go-version: ['1.23', '1.24']
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ matrix.go-version }}
      
      - name: Install dependencies
        run: go mod download
      
      - name: Run tests
        run: go test -v -race -coverprofile=coverage.out ./...
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.out
  
  lint:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
      
      - name: golangci-lint
        uses: golangci/golangci-lint-action@v3
        with:
          version: latest
```

## 测试最佳实践

### 1. 测试命名

```go
// 好的测试命名
func TestNew(t *testing.T)
func TestSetValue(t *testing.T)
func TestSetValue_WithEmptyString(t *testing.T)
func TestSetValue_WithUnicode(t *testing.T)

// 不好的测试命名
func Test1(t *testing.T)
func Test2(t *testing.T)
func TestSomething(t *testing.T)
```

### 2. 测试组织

```go
// 按功能组织测试
func TestNew(t *testing.T) { }
func TestUpdate(t *testing.T) { }
func TestView(t *testing.T) { }

// 按场景组织测试
func TestUpdate_CharacterInput(t *testing.T) { }
func TestUpdate_CursorMovement(t *testing.T) { }
func TestUpdate_DeleteCharacter(t *testing.T) { }
```

### 3. 测试隔离

```go
// 每个测试应该独立运行
func TestA(t *testing.T) {
    // 不依赖其他测试
}

func TestB(t *testing.T) {
    // 不依赖其他测试
}
```

### 4. 测试清理

```go
func TestWithCleanup(t *testing.T) {
    // 设置
    file, _ := os.CreateTemp("", "test")
    defer os.Remove(file.Name())
    
    // 测试
    // ...
}
```

## 总结

Bubbles-CN 项目采用多层次的测试策略，确保代码质量和项目稳定性。开发者应该遵循测试规范，编写充分的测试用例。

### 测试要点

1. **单元测试**: 验证单个函数/方法的行为
2. **集成测试**: 验证多个组件的交互
3. **系统测试**: 验证整个系统的功能
4. **端到端测试**: 验证完整的用户场景
5. **性能测试**: 测试系统的性能
6. **竞态条件测试**: 检测并发问题

### 测试目标

- **覆盖率**: 单元测试覆盖率 80% 以上
- **性能**: View() < 10ms, Update() < 5ms
- **稳定性**: 所有测试通过，无竞态条件
- **可维护性**: 测试代码清晰、易于维护
